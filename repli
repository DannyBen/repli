#!/usr/bin/env bash
# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
repli_usage() {
  printf "repli - Replicate AI Workspace Tool\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli COMMAND\n"
  printf "  repli [COMMAND] --help | -h\n"
  printf "  repli --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new configuration file from a tmeplate\n" "$(green "new")      "
  printf "  %s   Call Replicate using a configuration file and save the result\n" "$(green "get")      "
  printf "  %s   Edit the repli file\n" "$(green "edit")     "
  printf "  %s   Show the repli file\n" "$(green "show")     "
  printf "  %s   Get information on a model\n" "$(green "info")     "
  printf "  %s   Manage templates\n" "$(green "templates")"
  printf "  %s   Manage uploaded files\n" "$(green "files")    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(green "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLICATE_API_TOKEN (required)")"
    printf "    Replicate API token\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_LOG_LEVEL")"
    printf "    Log level\n"
    printf "    %s\n" "Allowed: debug, info, warn, error"
    printf "    %s\n" "Default: info"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_TEMPLATES_DIR")"
    printf "    Path to templates dir\n"
    printf "    %s\n" "Default: $HOME/repli"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_FILE")"
    printf "    Name of the repli file\n"
    printf "    %s\n" "Default: repli.yaml"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLICATE_HOST")"
    printf "    Replicate host\n"
    printf "    %s\n" "Default: https://api.replicate.com"
    echo

  fi
}

# :command.usage
repli_new_usage() {
  printf "repli new - Create a new configuration file from a tmeplate\n\n"
  printf "Alias: n, init\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli new [SEARCH] [OPTIONS]\n"
  printf "  repli new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--force, -f")"
    printf "    Overwrite target file\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--exact, -e")"
    printf "    Forces exact search only (disables interactive menu)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string or an exact name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli new flux\n"
    printf "  repli new flux-schnell -e\n"
    echo

  fi
}

# :command.usage
repli_get_usage() {
  printf "repli get - Call Replicate using a configuration file and save the result\n\n"
  printf "Alias: g\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli get [PREFIX] [OPTIONS]\n"
  printf "  repli get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "PREFIX")"
    printf "    Prefix for saved JSON file and output files\n"
    echo

  fi
}

# :command.usage
repli_edit_usage() {
  printf "repli edit - Edit the repli file\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli edit [OPTIONS]\n"
  printf "  repli edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_show_usage() {
  printf "repli show - Show the repli file\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli show [OPTIONS]\n"
  printf "  repli show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_info_usage() {
  printf "repli info - Get information on a model\n\n"
  printf "Alias: i\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli info MODEL [OPTIONS]\n"
  printf "  repli info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--example, -e")"
    printf "    Show the example only\n"
    printf "    %s\n" "Conflicts: --schema"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--schema, -s")"
    printf "    Show the schema only\n"
    printf "    %s\n" "Conflicts: --example"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--plain, -p")"
    printf "    Disable output colors\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--json, -j")"
    printf "    Output JSON instead of YAML\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "MODEL")"
    printf "    Model name on replicate\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli info google/nano-banana\n"
    printf "  repli info google/nano-banana --example --plain --json\n"
    echo

  fi
}

# :command.usage
repli_templates_usage() {
  printf "repli templates - Manage templates\n\n"
  printf "Alias: t\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates COMMAND\n"
  printf "  repli templates [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Add a new template from a remote Replicate model example\n" "$(green "new")   "
  printf "  %s   Show list of templates\n" "$(green "list")  "
  printf "  %s   Show template\n" "$(green "show")  "
  printf "  %s   Open template in editor\n" "$(green "edit")  "
  printf "  %s   Delete template file\n" "$(green "delete")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_templates_new_usage() {
  printf "repli templates new - Add a new template from a remote Replicate model example\n\n"
  printf "Alias: n, add\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates new MODEL [OPTIONS]\n"
  printf "  repli templates new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--force, -f")"
    printf "    Overwrite target file\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--name, -n NAME")"
    printf "    Template name to save\n"
    printf "    %s\n" "Default: auto"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "MODEL")"
    printf "    Replicate model (author/model)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli add google/nano-banana banana\n"
    echo

  fi
}

# :command.usage
repli_templates_list_usage() {
  printf "repli templates list - Show list of templates\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates list [SEARCH]\n"
  printf "  repli templates list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string\n"
    echo

  fi
}

# :command.usage
repli_templates_show_usage() {
  printf "repli templates show - Show template\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates show TEMPLATE\n"
  printf "  repli templates show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "TEMPLATE")"
    printf "    Template name\n"
    echo

  fi
}

# :command.usage
repli_templates_edit_usage() {
  printf "repli templates edit - Open template in editor\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates edit TEMPLATE\n"
  printf "  repli templates edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "TEMPLATE")"
    printf "    Template name\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "EDITOR")"
    printf "    Editor to use\n"
    printf "    %s\n" "Default: vi"
    echo

  fi
}

# :command.usage
repli_templates_delete_usage() {
  printf "repli templates delete - Delete template file\n\n"
  printf "Alias: d, del, rm\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli templates delete TEMPLATE\n"
  printf "  repli templates delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "TEMPLATE")"
    printf "    Template name\n"
    echo

  fi
}

# :command.usage
repli_files_usage() {
  printf "repli files - Manage uploaded files\n\n"
  printf "Alias: f\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli files COMMAND\n"
  printf "  repli files [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Show list of uploaded files\n" "$(green "list")  "
  printf "  %s   Upload a file to Replicate\n" "$(green "upload")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_files_list_usage() {
  printf "repli files list - Show list of uploaded files\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli files list [OPTIONS]\n"
  printf "  repli files list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--plain, -p")"
    printf "    Disable output colors\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--json, -j")"
    printf "    Output JSON instead of YAML\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_files_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "repli files upload\n\n"
    printf "  Upload a file to Replicate\n  Note that under normal conditions, there should be no reason for you to use\n  this directly. Files will be uploaded automatically as needed.\n\n"
  else
    printf "repli files upload - Upload a file to Replicate\n\n"
  fi
  printf "Alias: u\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli files upload FILE\n"
  printf "  repli files upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "FILE")"
    printf "    Path to file\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/download_outputs.sh
# usage: download_outputs PREFIX json_file
download_outputs() {
  local prefix="$1"
  local json_file="$2"
  local filename

  if [[ ! -f "$json_file" ]]; then
    log error file not found: "$(blue "$json_file")"
    return 1
  fi

  # Extract URLs (string → array, array → array)
  readarray -t urls < <(
    jq -r '
      (.output | if type=="string" then [.] else . end)
      | .[]
    ' "$json_file"
  )

  if [[ ${#urls[@]} -eq 0 || "${urls[0]}" == "null" ]]; then
    log warn no outputs found in "$(blue "$json_file")"
    return 0
  fi

  for url in "${urls[@]}"; do
    filename="${prefix}_$(basename "$url")"

    if [[ -f "$filename" ]]; then
      log info "skipping download, file exists: $(blue "$filename")"
      continue
    fi

    log debug "downloading from: $(underlined "$url")"
    log info "downloading to $(blue "$filename")"

    wget -q -O "$filename" "$url" ||
      log error "failed to download: $(underlined "$url")"

  done
}

# src/lib/filters/templates_dir_exist.sh
filter_templates_dir_exists() {
  if [[ ! -d "$templates_dir" ]]; then
    echo "Templates dir not found ($templates_dir), set using REPLI_TEMPLATES_DIR"
  fi
}

# src/lib/get_example_from_replicate.sh
get_example_from_replicate() {
  json=$(get_model_info "$model") || return 1

  jq --arg model "$model" \
    '{model: $model, input: .default_example.input}' \
    <<<"$json" |
    yq -P -
}

# src/lib/get_file_url.sh
get_file_url() {
  local file="$1"
  local files_list="files.ini"

  if [[ -f "$files_list" ]]; then
    log debug reading files list: "$(blue "$files_list")"

    while IFS='=' read -r path url; do
      if [[ "$path" == "$file" ]]; then
        log debug file already registered in "$(blue "$files_list")"
        log debug "$file → $url"
        echo "$url"
        return 0
      fi
    done <"$files_list"
  fi

  log info uploading file: "$(blue "$file")"
  url="$(upload_to_replicate "$file")"
  log debug file url: "$(underlined "$url")"
  log debug saving URL to "$(blue "$files_list")"
  echo "$file=$url" >>"$files_list"
  echo "$url"
}

# src/lib/get_files_list.sh
get_files_list() {
  curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$replicate_host/v1/files"
}

# src/lib/get_model_info.sh
get_model_info() {
  local model="$1"
  local body status

  # Capture body AND HTTP status code
  log debug calling replicate API
  body=$(curl -s -w "\n%{http_code}" \
    -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
    "$replicate_host/v1/models/$model")

  # Split last line as status code, everything above is the JSON body
  status=$(tail -n1 <<<"$body")
  body=$(sed '$d' <<<"$body")

  # Any 4xx or 5xx status means error
  if [[ "$status" -ge 400 ]]; then
    log error "failed getting model info for $(blue "$model")"
    log error "($status) $(jq -r '.detail // empty' <<<"$body")"
    return 1
  fi

  printf '%s\n' "$body"
}

# src/lib/get_templates_list.sh
get_templates_list() {
  local search="${1:-.}" # optional search term

  while IFS= read -r -d '' file; do
    basename -s .yaml "$file"
  done < <(
    find "$templates_dir" -maxdepth 1 -type f -name '*.yaml' -print0 |
      grep -iz "$search" |
      sort -zV
  ) | tr '\n' '\0'
}

# src/lib/get_unique_filename.sh
get_unique_filename() {
  local base="$1"
  local max=0
  local n

  for f in "${base}-"*; do
    [[ -e "$f" ]] || continue # skip if no match

    if [[ $f =~ ${base}-([0-9]+) ]]; then
      n="${BASH_REMATCH[1]}"
      ((n > max)) && max="$n"
    fi
  done

  echo "${base}-$((max + 1))"
}

# src/lib/log.sh
log() {
  local level="$1"
  shift
  local msg="$*"
  local caller color_func rank_req rank_cur

  case "$level" in
    debug) rank_req=10 ;;
    info) rank_req=20 ;;
    warn) rank_req=30 ;;
    error) rank_req=40 ;;
    *) rank_req=20 ;;
  esac

  case "$log_level" in
    debug) rank_cur=10 ;;
    info) rank_cur=20 ;;
    warn) rank_cur=30 ;;
    error) rank_cur=40 ;;
    *) rank_cur=20 ;;
  esac

  # filter by level
  [[ $rank_req -lt $rank_cur ]] && return 0

  # choose color function
  color_func="cyan"
  case "$level" in
    debug) color_func="magenta" ;;
    info) color_func="green" ;;
    warn) color_func="yellow_bold" ;;
    error) color_func="red_bold" ;;
  esac

  if [[ "$log_level" == "debug" ]]; then
    caller="${FUNCNAME[1]}"
    printf "$(green_bold "•") %s • %s $(green_bold →) %s\n" \
      "$("$color_func" "$level")" "$(cyan "$caller")" "$msg" >&2
  else
    printf "$(green_bold "•") %s $(green_bold →) %s\n" \
      "$("$color_func" "$level")" "$msg" >&2
  fi
}

# src/lib/replace_file_placeholders.sh
replace_file_placeholders() {
  local json="$1"
  local url
  local files=()

  # Find all "<filename>" occurrences in JSON values
  mapfile -t files < <(echo "$json" | jq -r '
    .. | select(type == "string") |
    match("^<(.+)>$")? | .captures[0].string
  ')

  # Replace each placeholder with uploaded file URL
  for file in "${files[@]}"; do
    url=$(get_file_url "$file")
    json=$(echo "$json" | jq --arg f "<$file>" --arg u "$url" '
      (.. | select(type=="string" and .==$f)) |= $u
    ')
  done

  echo "$json"
}

# src/lib/show_templates_list.sh
show_templates_list() {
  local search="${1:-.}" # optional search term

  echo "Templates in $(blue "$templates_dir"):"
  echo

  mapfile -d '' templates < <(get_templates_list "$search")

  if ((${#templates[@]} == 0)); then
    echo "  No templates found."
    echo
    return
  fi

  i=1
  for f in "${templates[@]}"; do
    echo " $i. $f"
    ((i++))
  done

  echo
}

# src/lib/upload_to_replicate.sh
upload_to_replicate() {
  local input_file="$1"

  file=$(curl -s -X POST "$replicate_host/v1/files" \
    -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
    -H "Content-Type: multipart/form-data" \
    -F "content=@$input_file;type=application/octet-stream;title=$(basename "$input_file")")

  input_file_url=$(echo "$file" | jq -r '.urls.get')
  if [[ -z "$input_file_url" ]]; then
    log error "could not get file URL"
    log debug "$file"
    return 1
  fi

  echo "$input_file_url"
}

# src/lib/validations/dir_exists.sh
validate_dir_exists() {
  if [[ ! -d "$1" ]]; then
    echo "must be an existing directory"
  fi
}

# src/lib/validations/file_exists.sh
validate_file_exists() {
  if [[ ! -f "$1" ]]; then
    echo "must be an existing file"
  fi
}

# src/lib/validations/integer.sh
validate_integer() {
  if ! [[ "$1" =~ ^[0-9]+$ ]]; then
    echo "must be an integer"
  fi
}

# src/lib/validations/model_name.sh
validate_model_name() {
  if ! [[ "$1" =~ ^[^/]+/[^/]+$ ]]; then
    echo "must be in the form of author/model"
  fi
}

# src/lib/validations/template_exists.sh
validate_template_exists() {
  if [[ ! -f "$templates_dir/$1.yaml" ]]; then
    echo "must be an existing template"
  fi
}

# src/lib/verify_success_json.sh
verify_success_json() {
  local json_file="$1"
  local status

  if [[ ! -f "$json_file" ]]; then
    log error "file not found: $(blue "$json_file")"
    return 1
  fi

  status=$(jq -r '.status // empty' "$json_file")

  [[ "$status" == "succeeded" ]] && return 0
  log error "received invalid response:"
  yq -P -oy "$json_file"
  return 1
}

# src/lib/yurl.sh
yurl() {
  local yaml_file="$1"
  local model input_json final_json

  # YAML validation
  if ! yq -e '.model' "$yaml_file" >/dev/null 2>&1; then
    log error "no model field in $(blue "$yaml_file")"
    return 1
  fi

  if ! yq -e '.input' "$yaml_file" >/dev/null 2>&1; then
    log error "no input field in $(blue "$yaml_file")"
    return 1
  fi

  # Get the model
  model=$(yq -r '.model' "$yaml_file")

  # Convert .input YAML → JSON
  input_json=$(yq -o=json '.input' "$yaml_file")

  # Replace any "<filename>" placeholders
  final_json=$(replace_file_placeholders "$input_json")

  # Pipe the evaluated JSON to curl which uses it (@-) as its data.
  echo "$final_json" |
    jq '{input: .}' |
    curl -sS -X POST \
      -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
      -H "Content-Type: application/json" \
      -H "Prefer: wait" \
      -d @- \
      "$replicate_host/v1/models/${model}/predictions"
}

# :command.command_functions
# :command.function
repli_new_command() {

  # src/commands/new.sh
  search="${args[search]}"
  outfile="${args[--use]}"
  force="${args[--force]}"
  exact="${args[--exact]}"

  # Do not overwrite unless --force is used
  if [[ -e "$outfile" && -z "$force" ]]; then
    log error "target already exists: $(blue "$outfile")"
    log info "use $(blue --force) to overwrite or $(blue --output PATH) to save to another file"
    return 1
  fi

  # Get templates list matching the search
  mapfile -d '' templates < <(get_templates_list "$search")

  # No matches
  if [[ ${#templates[@]} -eq 0 ]]; then
    log error "no matching templates"
    return 1
  fi

  if [[ ${#templates[@]} -eq 1 ]]; then
    # Exactly one match → auto-select
    selected="${templates[0]}"
  else
    # Show interactive menu
    show_templates_list "$search"

    if [[ "$exact" ]]; then
      log error "no exact match"
      return 1
    fi

    read -rp "Choose a template (1-${#templates[@]}): " choice

    # Validate selection
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || ((choice < 1 || choice > ${#templates[@]})); then
      log error "invalid selection"
      return 1
    fi

    selected="${templates[choice - 1]}"
  fi

  # Copy file
  infile="${templates_dir}/${selected}.yaml"
  log info "copying $(blue "$infile") → $(blue "$outfile")"
  cp "$infile" "$outfile"

}

# :command.function
repli_get_command() {

  # src/commands/get.sh
  config="${args[--use]}"
  prefix="${args[prefix]:-$(get_unique_filename "$(basename "$config" ".yaml")")}"

  outfile="${prefix}.json"
  log debug config: "$(blue "$config")"
  log debug prefix: "$(blue "$prefix")"
  log debug outfile: "$(blue "$outfile")"

  # call API unless the JSON is already saved
  if [[ -f "$outfile" ]]; then
    log info skipping API call, file exists: "$(blue "$outfile")"
  else
    log info calling API and saving "$(blue "$outfile")"
    yurl "$config" >"$outfile"
  fi

  # download outputs
  if verify_success_json "$outfile"; then
    download_outputs "$prefix" "$outfile"
  fi

}

# :command.function
repli_edit_command() {

  # src/commands/edit.sh
  config="${args[--use]}"
  "${EDITOR}" "$config"

}

# :command.function
repli_show_command() {

  # src/commands/show.sh
  file="${args[--use]}"
  yq -P -oy "$file"

}

# :command.function
repli_info_command() {

  # src/commands/info.sh
  model="${args[model]}"
  plain="${args[--plain]}"
  example="${args[--example]}"
  schema="${args[--schema]}"
  json="${args[--json]}"
  node="."

  if [[ -n "$json" ]]; then
    parser="jq"
    opts=()
  else
    parser="yq"
    opts=(-P)
  fi

  [[ -n "$example" ]] && node=".default_example.input"
  [[ -n "$schema" ]] && node=".latest_version.openapi_schema.components.schemas.Input"
  [[ -n "$plain" ]] && opts+=("-M")

  get_model_info "$model" | "$parser" "${opts[@]}" "$node"

}

# :command.function
repli_templates_new_command() {

  # src/commands/templates/new.sh
  model="${args[model]}"
  name="${args[--name]}"
  force="${args[--force]}"

  [[ "$name" == "auto" ]] && name="${model#*/}"

  outpath="$templates_dir/$name.yaml"

  if [[ -f "$outpath" && ! "$force" ]]; then
    log debug "target: $(blue "$outpath")"
    log error "target already exists: $(blue "$name")"
    log info "use $(blue --force) to overwrite or $(blue --output NAME) to save with another name"
    return 1
  fi

  mkdir -p "$templates_dir"
  log debug "fetching example for $(blue "$model")"
  template="$(get_example_from_replicate "$model")"

  log info "saving to $(blue "$outpath")"
  [[ -n "$template" ]] && printf "%s\n" "$template" >"$outpath"

}

# :command.function
repli_templates_list_command() {

  # src/commands/templates/list.sh
  search="${args[search]}"
  show_templates_list "$search"

}

# :command.function
repli_templates_show_command() {

  # src/commands/templates/show.sh
  template="${args[template]}"
  file="$templates_dir/$template.yaml"
  yq -P -oy "$file"

}

# :command.function
repli_templates_edit_command() {

  # src/commands/templates/edit.sh
  template="${args[template]}"
  file="$templates_dir/$template.yaml"
  "${EDITOR}" "$file"

}

# :command.function
repli_templates_delete_command() {

  # src/commands/templates/delete.sh
  template="${args[template]}"
  file="$templates_dir/$template.yaml"
  log info "deleting $file"
  rm "$file"

}

# :command.function
repli_files_list_command() {

  # src/commands/files/list.sh
  plain="${args[--plain]}"
  json="${args[--json]}"

  if [[ -n "$json" ]]; then
    parser="jq"
    opts=()
  else
    parser="yq"
    opts=(-P)
  fi

  [[ -n "$plain" ]] && opts+=("-M")
  get_files_list | "$parser" "${opts[@]}" .results

}

# :command.function
repli_files_upload_command() {

  # src/commands/files/upload.sh
  file="${args[file]}"
  files_list="files.ini"

  if [[ -f "$files_list" ]]; then
    log debug reading files list: "$(blue "$files_list")"

    while IFS='=' read -r path url; do
      if [[ "$path" == "$file" ]]; then
        log info upload skipped, already registered in "$(blue "$files_list")"
        log info url: "$url"
        return 0
      fi
    done <"$files_list"
  fi

  log info uploading "$(blue "$file")"
  url="$(upload_to_replicate "$file")"
  log info url: "$(underlined "$url")"

  log info saving URL to "$(blue "$files_list")"
  echo "$file=$url" >>"$files_list"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        repli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export REPLI_LOG_LEVEL="${REPLI_LOG_LEVEL:-info}"
  export REPLI_TEMPLATES_DIR="${REPLI_TEMPLATES_DIR:-$HOME/repli}"
  export REPLI_FILE="${REPLI_FILE:-repli.yaml}"
  export REPLICATE_HOST="${REPLICATE_HOST:-https://api.replicate.com}"

  env_var_names+=("REPLICATE_API_TOKEN")
  env_var_names+=("REPLI_LOG_LEVEL")
  env_var_names+=("REPLI_TEMPLATES_DIR")
  env_var_names+=("REPLI_FILE")
  env_var_names+=("REPLICATE_HOST")
  if [[ -z "${REPLICATE_API_TOKEN:-}" ]]; then
    printf "missing required environment variable: REPLICATE_API_TOKEN\n" >&2
    exit 1
  fi
  if [[ -n "${REPLI_LOG_LEVEL:-}" ]] && [[ ! ${REPLI_LOG_LEVEL:-} =~ ^(debug|info|warn|error)$ ]]; then
    printf "%s\n" "REPLI_LOG_LEVEL environment variable must be one of: debug, info, warn, error" >&2
    exit 1
  fi

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  # :dependency.filter
  if ! command -v wget >/dev/null 2>&1; then
    printf "missing dependency: wget\n" >&2
    missing_deps=1
  else
    deps['wget']="$(command -v wget | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    new | n | init)
      action="new"
      shift
      repli_new_parse_requirements "$@"
      shift $#
      ;;

    get | g)
      action="get"
      shift
      repli_get_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      repli_edit_parse_requirements "$@"
      shift $#
      ;;

    show | s)
      action="show"
      shift
      repli_show_parse_requirements "$@"
      shift $#
      ;;

    info | i)
      action="info"
      shift
      repli_info_parse_requirements "$@"
      shift $#
      ;;

    templates | t)
      action="templates"
      shift
      repli_templates_parse_requirements "$@"
      shift $#
      ;;

    files | f)
      action="files"
      shift
      repli_files_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_new_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --exact | -e)

        # :flag.case_no_arg
        args['--exact']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_get_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['prefix']+x} ]]; then
          args['prefix']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_edit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_show_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_info_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --example | -e)
        # :flag.conflicts
        if [[ -n "${args['--schema']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--schema" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--example']=1
        shift
        ;;

      # :flag.case
      --schema | -s)
        # :flag.conflicts
        if [[ -n "${args['--example']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--example" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--schema']=1
        shift
        ;;

      # :flag.case
      --plain | -p)

        # :flag.case_no_arg
        args['--plain']=1
        shift
        ;;

      # :flag.case
      --json | -j)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: repli info MODEL [OPTIONS]\n" >&2
    # :command.examples_on_error
    printf "examples:\n" >&2
    printf "  repli info google/nano-banana\n" >&2
    printf "  repli info google/nano-banana --example --plain --json\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['model'] ]]; then
    validation_output="$(validate_model_name "${args['model']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "MODEL" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_templates_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    new | n | add)
      action="new"
      shift
      repli_templates_new_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      repli_templates_list_parse_requirements "$@"
      shift $#
      ;;

    show | s)
      action="show"
      shift
      repli_templates_show_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      repli_templates_edit_parse_requirements "$@"
      shift $#
      ;;

    delete | d | del | rm)
      action="delete"
      shift
      repli_templates_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_templates_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_templates_new_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="templates new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: repli templates new MODEL [OPTIONS]\n" >&2
    # :command.examples_on_error
    printf "examples:\n" >&2
    printf "  repli add google/nano-banana banana\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--name']:-} ]] || args['--name']="auto"

  # :command.validations
  # :argument.validations
  if [[ -v args['model'] ]]; then
    validation_output="$(validate_model_name "${args['model']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "MODEL" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_templates_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="templates list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_templates_show_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="templates show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['template']+x} ]]; then
          args['template']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['template']+x} ]]; then
    printf "missing required argument: TEMPLATE\nusage: repli templates show TEMPLATE\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['template'] ]]; then
    validation_output="$(validate_template_exists "${args['template']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "TEMPLATE" "$validation_output" >&2
      exit 1
    fi
  fi

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_templates_edit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export EDITOR="${EDITOR:-vi}"

  env_var_names+=("EDITOR")

  # :command.command_filter
  action="templates edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['template']+x} ]]; then
          args['template']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['template']+x} ]]; then
    printf "missing required argument: TEMPLATE\nusage: repli templates edit TEMPLATE\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['template'] ]]; then
    validation_output="$(validate_template_exists "${args['template']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "TEMPLATE" "$validation_output" >&2
      exit 1
    fi
  fi

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_templates_delete_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_templates_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="templates delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['template']+x} ]]; then
          args['template']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['template']+x} ]]; then
    printf "missing required argument: TEMPLATE\nusage: repli templates delete TEMPLATE\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['template'] ]]; then
    validation_output="$(validate_template_exists "${args['template']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "TEMPLATE" "$validation_output" >&2
      exit 1
    fi
  fi

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_files_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_files_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      repli_files_list_parse_requirements "$@"
      shift $#
      ;;

    upload | u)
      action="upload"
      shift
      repli_files_upload_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_files_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_files_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_files_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="files list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --plain | -p)

        # :flag.case_no_arg
        args['--plain']=1
        shift
        ;;

      # :flag.case
      --json | -j)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_files_upload_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_files_upload_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="files upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['file']+x} ]]; then
          args['file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['file']+x} ]]; then
    printf "missing required argument: FILE\nusage: repli files upload FILE\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['file'] ]]; then
    validation_output="$(validate_file_exists "${args['file']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "FILE" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.2"
  set -eo pipefail

  # :command.environment_variables_default
  export REPLI_LOG_LEVEL="${REPLI_LOG_LEVEL:-info}"
  export REPLI_TEMPLATES_DIR="${REPLI_TEMPLATES_DIR:-$HOME/repli}"
  export REPLI_FILE="${REPLI_FILE:-repli.yaml}"
  export REPLICATE_HOST="${REPLICATE_HOST:-https://api.replicate.com}"

  # :command.variables
  # :variable.definition
  declare -g templates_dir="$REPLI_TEMPLATES_DIR"

  # :variable.definition
  declare -g log_level="$REPLI_LOG_LEVEL"

  # :variable.definition
  declare -g replicate_host="$REPLICATE_HOST"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "new") repli_new_command ;;
    "get") repli_get_command ;;
    "edit") repli_edit_command ;;
    "show") repli_show_command ;;
    "info") repli_info_command ;;
    "templates") repli_templates_command ;;
    "templates new") repli_templates_new_command ;;
    "templates list") repli_templates_list_command ;;
    "templates show") repli_templates_show_command ;;
    "templates edit") repli_templates_edit_command ;;
    "templates delete") repli_templates_delete_command ;;
    "files") repli_files_command ;;
    "files list") repli_files_list_command ;;
    "files upload") repli_files_upload_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
