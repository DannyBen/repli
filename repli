#!/usr/bin/env bash
# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
repli_usage() {
  printf "repli - Replicate AI Workspace Tool\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli COMMAND\n"
  printf "  repli [COMMAND] --help | -h\n"
  printf "  repli --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Create a new configuration file from a tmeplate\n" "$(green "new")     "
  printf "  %s   Call Replicate using a configuration file and save the result\n" "$(green "get")     "
  printf "  %s   Edit the repli file\n" "$(green "edit")    "
  printf "  %s   Show the repli file\n" "$(green "show")    "
  printf "  %s   Show repli environment information\n" "$(green "env")     "
  printf "  %s   Get information on a model\n" "$(green "info")    "
  printf "  %s   Manage templates\n" "$(green "template")"
  printf "  %s   Manage uploaded files\n" "$(green "file")    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "$(green "--version, -v")"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLICATE_API_TOKEN (required)")"
    printf "    Replicate API token\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_LOG_LEVEL")"
    printf "    Log level\n"
    printf "    %s\n" "Allowed: debug, info, warn, error"
    printf "    %s\n" "Default: info"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_TEMPLATES_DIR")"
    printf "    Path to templates dir\n"
    printf "    %s\n" "Default: $HOME/repli"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_FILE")"
    printf "    Name of the repli file\n"
    printf "    %s\n" "Default: repli.yaml"
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLI_OUTPUT_DIR")"
    printf "    Output directory for all files\n"
    printf "    %s\n" "Default: ."
    echo

    # :environment_variable.usage
    printf "  %s\n" "$(green "REPLICATE_HOST")"
    printf "    Replicate host\n"
    printf "    %s\n" "Default: https://api.replicate.com"
    echo

  fi
}

# :command.usage
repli_new_usage() {
  printf "repli new - Create a new configuration file from a tmeplate\n\n"
  printf "Alias: n, init\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli new [SEARCH] [OPTIONS]\n"
  printf "  repli new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--force, -f")"
    printf "    Overwrite target file\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--exact, -e")"
    printf "    Forces exact search only (disables interactive menu)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string or an exact name\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli new flux\n"
    printf "  repli new flux-schnell -e\n"
    echo

  fi
}

# :command.usage
repli_get_usage() {
  printf "repli get - Call Replicate using a configuration file and save the result\n\n"
  printf "Alias: g\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli get [PREFIX] [OPTIONS]\n"
  printf "  repli get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "PREFIX")"
    printf "    Prefix for saved JSON file and output files\n"
    echo

  fi
}

# :command.usage
repli_edit_usage() {
  printf "repli edit - Edit the repli file\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli edit [OPTIONS]\n"
  printf "  repli edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_show_usage() {
  printf "repli show - Show the repli file\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli show [OPTIONS]\n"
  printf "  repli show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--use, -u PATH")"
    printf "    Path to repli file\n"
    printf "    %s\n" "Default: $REPLI_FILE"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_env_usage() {
  printf "repli env - Show repli environment information\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli env\n"
  printf "  repli env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_info_usage() {
  printf "repli info - Get information on a model\n\n"
  printf "Alias: i\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli info MODEL [OPTIONS]\n"
  printf "  repli info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--example, -e")"
    printf "    Show the example only\n"
    printf "    %s\n" "Conflicts: --schema"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--schema, -s")"
    printf "    Show the schema only\n"
    printf "    %s\n" "Conflicts: --example"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--plain, -p")"
    printf "    Disable output colors\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--json, -j")"
    printf "    Output JSON instead of YAML\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "MODEL")"
    printf "    Model name on replicate\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli info google/nano-banana\n"
    printf "  repli info google/nano-banana --example --plain --json\n"
    echo

  fi
}

# :command.usage
repli_template_usage() {
  printf "repli template - Manage templates\n\n"
  printf "Alias: t\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template COMMAND\n"
  printf "  repli template [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Add a new template from a remote Replicate model example\n" "$(green "new")   "
  printf "  %s   Show list of templates\n" "$(green "list")  "
  printf "  %s   Find templates that contain a string in their YAML\n" "$(green "grep")  "
  printf "  %s   Show template\n" "$(green "show")  "
  printf "  %s   Open template in editor\n" "$(green "edit")  "
  printf "  %s   Delete template file\n" "$(green "delete")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_template_new_usage() {
  printf "repli template new - Add a new template from a remote Replicate model example\n\n"
  printf "Alias: n, add\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template new MODEL [OPTIONS]\n"
  printf "  repli template new --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--force, -f")"
    printf "    Overwrite target file\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--name, -n NAME")"
    printf "    Template name to save\n"
    printf "    %s\n" "Default: auto"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "MODEL")"
    printf "    Replicate model (author/model)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  repli add google/nano-banana --name banana\n"
    echo

  fi
}

# :command.usage
repli_template_list_usage() {
  printf "repli template list - Show list of templates\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template list [SEARCH]\n"
  printf "  repli template list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string\n"
    echo

  fi
}

# :command.usage
repli_template_grep_usage() {
  printf "repli template grep - Find templates that contain a string in their YAML\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template grep SEARCH\n"
  printf "  repli template grep --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Search string\n"
    echo

  fi
}

# :command.usage
repli_template_show_usage() {
  printf "repli template show - Show template\n\n"
  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template show [SEARCH]\n"
  printf "  repli template show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string or an exact name\n"
    echo

  fi
}

# :command.usage
repli_template_edit_usage() {
  printf "repli template edit - Open template in editor\n\n"
  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template edit [SEARCH]\n"
  printf "  repli template edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string or an exact name\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "$(green "EDITOR")"
    printf "    Editor to use\n"
    printf "    %s\n" "Default: vi"
    echo

  fi
}

# :command.usage
repli_template_delete_usage() {
  printf "repli template delete - Delete template file\n\n"
  printf "Alias: d, del, rm\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli template delete [SEARCH]\n"
  printf "  repli template delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "SEARCH")"
    printf "    Template search string or an exact name\n"
    echo

  fi
}

# :command.usage
repli_file_usage() {
  printf "repli file - Manage uploaded files\n\n"
  printf "Alias: f\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli file COMMAND\n"
  printf "  repli file [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Show list of uploaded files\n" "$(green "list")  "
  printf "  %s   Upload a file to Replicate\n" "$(green "upload")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_file_list_usage() {
  printf "repli file list - Show list of uploaded files\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli file list [OPTIONS]\n"
  printf "  repli file list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "$(green "--plain, -p")"
    printf "    Disable output colors\n"
    echo

    # :flag.usage
    printf "  %s\n" "$(green "--json, -j")"
    printf "    Output JSON instead of YAML\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
repli_file_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "repli file upload\n\n"
    printf "  Upload a file to Replicate\n  Note that under normal conditions, there should be no reason for you to use\n  this directly. Files will be uploaded automatically as needed.\n\n"
  else
    printf "repli file upload - Upload a file to Replicate\n\n"
  fi
  printf "Alias: u\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  repli file upload FILE\n"
  printf "  repli file upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "$(green "--help, -h")"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "$(green "FILE")"
    printf "    Path to file\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/core/get_files_list.sh
get_files_list() {
  curl -s -H "Authorization: Token $REPLICATE_API_TOKEN" "$replicate_host/v1/files"
}

# src/lib/core/get_model_info.sh
get_model_info() {
  local model="$1"
  local body status

  # Capture body AND HTTP status code
  log debug calling replicate API
  body=$(curl -s -w "\n%{http_code}" \
    -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
    "$replicate_host/v1/models/$model")

  # Split last line as status code, everything above is the JSON body
  status=$(tail -n1 <<<"$body")
  body=$(sed '$d' <<<"$body")

  # Any 4xx or 5xx status means error
  if [[ "$status" -ge 400 ]]; then
    log error "failed getting model info for $(blue "$model")"
    log error "($status) $(jq -r '.detail // empty' <<<"$body")"
    return 1
  fi

  printf '%s\n' "$body"
}

# src/lib/core/yurl.sh
yurl() {
  local yaml_file="$1"
  local model version json payload url

  # YAML validation
  if ! yq -e '.input' "$yaml_file" >/dev/null 2>&1; then
    log error "no input field in $(blue "$yaml_file")"
    return 1
  fi

  model=$(yq -r '.model // ""' "$yaml_file")
  version=$(yq -r '.version // ""' "$yaml_file")

  if [[ -z "$model" && -z "$version" ]]; then
    log error "no model or version field in $(blue "$yaml_file")"
    return 1
  fi

  # Convert .input YAML → JSON and replace <filename> and ~filename.txt
  payload=$(yq -o=json '.' "$yaml_file")
  payload=$(replace_file_placeholders "$payload")
  payload=$(replace_embed_markers "$payload")

  # Set payload and URL for official/unofficial models
  if [[ -n "$model" ]]; then
    payload=$(echo "$payload" | jq 'del(.model)')
    url="$replicate_host/v1/models/${model}/predictions"
  else
    url="$replicate_host/v1/predictions"
  fi

  # Pipe the evaluated JSON to curl which uses it (@-) as its data.
  echo "$payload" |
    curl -sS -X POST \
      -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
      -H "Content-Type: application/json" \
      -H "Prefer: wait" \
      -d @- \
      "$url"
}

# src/lib/file/download_outputs.sh
# usage: download_outputs PREFIX json_file
download_outputs() {
  local prefix="$1"
  local json_file="$2"
  local filename

  if [[ ! -f "$json_file" ]]; then
    log error file not found: "$(blue "$json_file")"
    return 1
  fi

  # Extract URLs (string → array, array → array)
  readarray -t urls < <(
    jq -r '
      (.output | if type=="string" then [.] else . end)
      | .[]
    ' "$json_file"
  )

  if [[ ${#urls[@]} -eq 0 || "${urls[0]}" == "null" ]]; then
    log warn no outputs found in "$(blue "$json_file")"
    return 0
  fi

  for url in "${urls[@]}"; do
    filename="${output_dir}/${prefix}_$(basename "$url")"

    if [[ -f "$filename" ]]; then
      log info "skipping download, file exists: $(blue "$filename")"
      continue
    fi

    log debug "downloading from: $(underlined "$url")"
    log info "downloading to $(blue "$filename")"

    wget -q -O "$filename" "$url" ||
      log error "failed to download: $(underlined "$url")"

  done
}

# src/lib/file/get_file_url.sh
get_file_url() {
  local file="$1"
  local files_list="$output_dir/files.ini"

  if [[ -f "$files_list" ]]; then
    log debug reading files list: "$(blue "$files_list")"

    while IFS='=' read -r path url; do
      if [[ "$path" == "$file" ]]; then
        log debug file already registered in "$(blue "$files_list")"
        log debug "$file → $url"
        echo "$url"
        return 0
      fi
    done <"$files_list"
  fi

  log info uploading file: "$(blue "$file")"
  url="$(upload_to_replicate "$file")"
  log debug file url: "$(underlined "$url")"
  log debug saving URL to "$(blue "$files_list")"
  echo "$file=$url" >>"$files_list"
  echo "$url"
}

# src/lib/file/get_unique_filename.sh
get_unique_filename() {
  local base="$1"
  local max=0
  local n

  for f in "${base}-"*; do
    [[ -e "$f" ]] || continue # skip if no match

    if [[ $f =~ ${base}-([0-9]+) ]]; then
      n="${BASH_REMATCH[1]}"
      ((n > max)) && max="$n"
    fi
  done

  echo "${base}-$((max + 1))"
}

# src/lib/file/replace_embed_markers.sh
replace_embed_markers() {
  local json="$1"
  local files=()
  local content

  # Find all "$(filename)" placeholders in JSON string values
  mapfile -t files < <(echo "$json" | jq -r '
    .. | select(type == "string") |
    match("^~(.+)$")? | .captures[0].string
  ')

  for file in "${files[@]}"; do
    if [[ ! -f "$file" ]]; then
      log error "embedded file not found: $(blue "$file")"
      return 1
    fi

    # Read raw file contents (preserve newlines)
    log debug "embedding $(blue "$file")"
    content=$(<"$file")

    # Use jq to replace the placeholder with file contents
    json=$(echo "$json" | jq \
      --arg placeholder "~$file" \
      --arg content "$content" \
      '(.. | select(type=="string" and .==$placeholder)) |= $content')

  done

  echo "$json"
}

# src/lib/file/replace_file_placeholders.sh
replace_file_placeholders() {
  local json="$1"
  local url
  local files=()

  # Find all "<filename>" occurrences in JSON values
  mapfile -t files < <(echo "$json" | jq -r '
    .. | select(type == "string") |
    match("^<(.+)>$")? | .captures[0].string
  ')

  # Replace each placeholder with uploaded file URL
  for file in "${files[@]}"; do
    if [[ ! -f "$file" ]]; then
      log error "upload file not found: $(blue "$file")"
      return 1
    fi

    log debug "replacing upload file marker $(blue "$file")"
    url=$(get_file_url "$file")
    json=$(echo "$json" | jq --arg f "<$file>" --arg u "$url" '
      (.. | select(type=="string" and .==$f)) |= $u
    ')
  done

  echo "$json"
}

# src/lib/file/upload_to_replicate.sh
upload_to_replicate() {
  local input_file="$1"

  file=$(curl -s -X POST "$replicate_host/v1/files" \
    -H "Authorization: Bearer $REPLICATE_API_TOKEN" \
    -H "Content-Type: multipart/form-data" \
    -F "content=@$input_file;type=application/octet-stream;title=$(basename "$input_file")")

  input_file_url=$(echo "$file" | jq -r '.urls.get')
  if [[ -z "$input_file_url" ]]; then
    log error "could not get file URL"
    log debug "$file"
    return 1
  fi

  echo "$input_file_url"
}

# src/lib/filters/templates_dir_exist.sh
filter_templates_dir_exists() {
  if [[ ! -d "$templates_dir" ]]; then
    echo "Templates dir not found ($templates_dir), set using REPLI_TEMPLATES_DIR"
  fi
}

# src/lib/json-parsers/json_get_model_properties.sh
json_get_model_properties() {
  local json="$1"

  # iterate over properties
  while read -r prop; do
    enums=$(json_get_prop_enums "$json" "$prop")
    [[ -n "$enums" ]] || enums='*'
    echo "$prop: $enums"
  done < <(json_get_model_properties_list "$json")
}

# src/lib/json-parsers/json_get_model_properties_list.sh
json_get_model_properties_list() {
  local json="$1"

  echo "$json" | jq -r '
    .latest_version.openapi_schema.components.schemas.Input.properties
    | keys[]
  '
}

# src/lib/json-parsers/json_get_prop_enums.sh
json_get_prop_enums() {
  local json="$1"
  local prop="$2"

  echo "$json" | jq -r --arg prop "$prop" '
    .latest_version.openapi_schema.components.schemas[$prop]
    | .. | objects | select(has("enum")) | .enum? // empty
    | join(", ")
  '
}

# src/lib/json-parsers/json_to_template.sh
json_to_template() {
  json="$1"

  # Determine whether the model is official
  is_official=$(jq -r '.is_official // false' <<<"$json")

  echo "# https://replicate.com/$model"
  echo

  if [[ "$is_official" == "true" ]]; then
    log debug "model status: $(blue official)"
    # Official image
    jq --arg model "$model" \
      '{model: $model, input: .default_example.input}' \
      <<<"$json" | yq -P -
  else
    # Non-official image: use version instead of model
    log debug "model status: $(blue unofficial)"
    version=$(jq -r '.latest_version.id' <<<"$json")

    jq --arg model "$model" --arg version "$version" \
      '{version: ($model + ":" + $version), input: .default_example.input}' \
      <<<"$json" | yq -P -
  fi

  echo
  echo "# PROPERTIES"
  mapfile -t props < <(json_get_model_properties "$json")
  for propline in "${props[@]}"; do
    echo "# $propline"
  done
}

# src/lib/json-parsers/json_verify_success_file.sh
json_verify_success_file() {
  local json_file="$1"
  local status

  if [[ ! -f "$json_file" ]]; then
    log error "file not found: $(blue "$json_file")"
    return 1
  fi

  status=$(jq -r '.status // empty' "$json_file")

  [[ "$status" == "succeeded" ]] && return 0
  log error "received invalid response:"
  yq -P -oy "$json_file"
  return 1
}

# src/lib/template/get_templates_list.sh
get_templates_list() {
  local search="${1:-}"

  while IFS= read -r -d '' rel; do
    # Strip .yaml
    local name="${rel%.yaml}"

    # If not nested, show only the basename
    if [[ "$rel" != */* ]]; then
      printf '%s\0' "$name"
    else
      # Keep the relative directory path
      printf '%s\0' "$name"
    fi

  done < <(
    find "$templates_dir" \
      -type f -name '*.yaml' \
      -printf '%P\0' | # <-- %P = path relative to $templates_dir
      grep -iz "$search" |
      sort -zV
  )
}

# src/lib/template/select_template.sh
select_template() {
  local search="$1"
  local exact="$2"

  # Get templates list matching the search
  mapfile -d '' templates < <(get_templates_list "$search")

  # No matches
  if [[ ${#templates[@]} -eq 0 ]]; then
    log error "no matching templates"
    return 1
  fi

  if [[ ${#templates[@]} -eq 1 ]]; then
    # Exactly one match → auto-select
    echo "${templates[0]}"
    return
  else
    # Show interactive menu
    show_templates_list "$search" >&2

    if [[ "$exact" ]]; then
      log error "no exact match"
      return 1
    fi

    read -rp "Choose a template (1-${#templates[@]}): " choice

    # Validate selection
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || ((choice < 1 || choice > ${#templates[@]})); then
      log error "invalid selection"
      return 1
    fi

    echo "${templates[choice - 1]}"
  fi
}

# src/lib/template/show_templates_list.sh
show_templates_list() {
  local search="${1:-.}" # optional search term

  echo "Templates in $(blue "$templates_dir"):"
  echo

  mapfile -d '' templates < <(get_templates_list "$search")

  if ((${#templates[@]} == 0)); then
    echo "  No templates found."
    echo
    return
  fi

  i=1
  for f in "${templates[@]}"; do
    echo " $i. $f"
    ((i++))
  done

  echo
}

# src/lib/utils/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/utils/log.sh
log() {
  local level="$1"
  shift
  local msg="$*"
  local caller color_func rank_req rank_cur

  case "$level" in
    debug) rank_req=10 ;;
    info) rank_req=20 ;;
    warn) rank_req=30 ;;
    error) rank_req=40 ;;
    *) rank_req=20 ;;
  esac

  case "$log_level" in
    debug) rank_cur=10 ;;
    info) rank_cur=20 ;;
    warn) rank_cur=30 ;;
    error) rank_cur=40 ;;
    *) rank_cur=20 ;;
  esac

  # filter by level
  [[ $rank_req -lt $rank_cur ]] && return 0

  # choose color function
  color_func="cyan"
  case "$level" in
    debug) color_func="magenta" ;;
    info) color_func="green" ;;
    warn) color_func="yellow_bold" ;;
    error) color_func="red_bold" ;;
  esac

  if [[ "$log_level" == "debug" ]]; then
    caller="${FUNCNAME[1]}"
    printf "$(green_bold "•") %s • %s $(green_bold →) %s\n" \
      "$("$color_func" "$level")" "$(cyan "$caller")" "$msg" >&2
  else
    printf "$(green_bold "•") %s $(green_bold →) %s\n" \
      "$("$color_func" "$level")" "$msg" >&2
  fi
}

# src/lib/validations/dir_exists.sh
validate_dir_exists() {
  if [[ ! -d "$1" ]]; then
    echo "must be an existing directory"
  fi
}

# src/lib/validations/file_exists.sh
validate_file_exists() {
  if [[ ! -f "$1" ]]; then
    echo "must be an existing file ($1)"
  fi
}

# src/lib/validations/integer.sh
validate_integer() {
  if ! [[ "$1" =~ ^[0-9]+$ ]]; then
    echo "must be an integer"
  fi
}

# src/lib/validations/model_name.sh
validate_model_name() {
  if ! [[ "$1" =~ ^[^/]+/[^/]+$ ]]; then
    echo "must be in the form of author/model"
  fi
}

# src/lib/validations/template_exists.sh
validate_template_exists() {
  if [[ ! -f "$templates_dir/$1.yaml" ]]; then
    echo "must be an existing template"
  fi
}

# :command.command_functions
# :command.function
repli_new_command() {

  # src/commands/new.sh
  local search="${args[search]}"
  local outfile="${args[--use]}"
  local force="${args[--force]}"
  local exact="${args[--exact]}"

  # Do not overwrite unless --force is used
  if [[ -e "$outfile" && -z "$force" ]]; then
    log error "target already exists: $(blue "$outfile")"
    log info "use $(blue --force) to overwrite or $(blue --output PATH) to save to another file"
    return 1
  fi

  selected="$(select_template "$search" "$exact")"

  # Copy file
  infile="${templates_dir}/${selected}.yaml"
  log info "copying $(blue "$infile") → $(blue "$outfile")"
  cp "$infile" "$outfile"

}

# :command.function
repli_get_command() {

  # src/commands/get.sh
  config="${args[--use]}"
  prefix="${args[prefix]:-$(get_unique_filename "$(basename "$config" ".yaml")")}"

  outfile="${output_dir}/${prefix}.json"
  log debug config: "$(blue "$config")"
  log debug prefix: "$(blue "$prefix")"
  log debug outfile: "$(blue "$outfile")"

  # call API unless the JSON is already saved
  if [[ -f "$outfile" ]]; then
    log info skipping API call, file exists: "$(blue "$outfile")"
  else
    log info calling API and saving "$(blue "$outfile")"
    yurl "$config" >"$outfile"
  fi

  # download outputs
  if json_verify_success_file "$outfile"; then
    download_outputs "$prefix" "$outfile"
  fi

}

# :command.function
repli_edit_command() {

  # src/commands/edit.sh
  local config="${args[--use]}"
  "${EDITOR}" "$config"

}

# :command.function
repli_show_command() {

  # src/commands/show.sh
  file="${args[--use]}"
  yq -P -oy "$file"

}

# :command.function
repli_env_command() {

  # src/commands/env.sh
  printf "REPLI_FILE:           %s\n" "$(yellow "$REPLI_FILE")"
  [[ -f "$REPLI_FILE" ]] && msg=$(green found) || msg=$(red "NOT FOUND")
  printf "REPLI_FILE status:    %s\n" "$msg"
  printf "REPLI_OUTPUT_DIR:     %s\n" "$(yellow "$output_dir")"
  printf "REPLI_TEMPLATES_DIR:  %s\n" "$(yellow "$templates_dir")"
  printf "REPLI_LOG_LEVEL:      %s\n" "$(yellow "$log_level")"
  printf "REPLICATE_HOST:       %s\n" "$(yellow "$replicate_host")"

  if [[ -z "$REPLICATE_API_TOKEN" ]]; then
    msg=$(red "NOT SET")
  else
    msg="$(printf "%s...%s" "${REPLICATE_API_TOKEN:0:3}" "${REPLICATE_API_TOKEN: -3}")"
    msg="$(yellow "$msg")"
  fi

  printf "REPLICATE_API_TOKEN:  %s\n" "$msg"

}

# :command.function
repli_info_command() {

  # src/commands/info.sh
  model="${args[model]}"
  plain="${args[--plain]}"
  example="${args[--example]}"
  schema="${args[--schema]}"
  json="${args[--json]}"
  node="."

  if [[ -n "$json" ]]; then
    parser="jq"
    opts=()
  else
    parser="yq"
    opts=(-P)
  fi

  [[ -n "$example" ]] && node=".default_example.input"
  [[ -n "$schema" ]] && node=".latest_version.openapi_schema.components.schemas.Input"
  [[ -n "$plain" ]] && opts+=("-M")

  get_model_info "$model" | "$parser" "${opts[@]}" "$node"

}

# :command.function
repli_template_new_command() {

  # src/commands/template/new.sh
  local model="${args[model]}"
  local name="${args[--name]}"
  local force="${args[--force]}"

  [[ "$name" == "auto" ]] && name="${model#*/}"

  outpath="$templates_dir/$name.yaml"

  if [[ -f "$outpath" && ! "$force" ]]; then
    log debug "target: $(blue "$outpath")"
    log error "target already exists: $(blue "$name")"
    log info "use $(blue --force) to overwrite or $(blue --output NAME) to save with another name"
    return 1
  fi

  mkdir -p "$templates_dir"
  log info "building template for $(blue "$model")"
  json=$(get_model_info "$model") || return 1
  template="$(json_to_template "$json")"
  if [[ -n "$template" ]]; then
    log info "saving to $(blue "$outpath")"
    printf "%s\n" "$template" >"$outpath"
  else
    log error "received an empty template"
  fi

}

# :command.function
repli_template_list_command() {

  # src/commands/template/list.sh
  search="${args[search]}"
  show_templates_list "$search"

}

# :command.function
repli_template_grep_command() {

  # src/commands/template/grep.sh
  local search="${args[search]}"

  echo "Templates: $(blue "$templates_dir")"
  echo "Search:    $(green "$search")"
  echo

  (
    cd "$templates_dir" >/dev/null || return 1

    find . \
      -type f -name '*.yaml' \
      -printf '%P\0' |
      xargs -0 grep -ilZ "$search" |
      sed -z 's/\.yaml$//' |
      sort -zV |
      tr '\0' '\n'
  )

}

# :command.function
repli_template_show_command() {

  # src/commands/template/show.sh
  local search="${args[search]}"
  template="$(select_template "$search")"
  file="$templates_dir/$template.yaml"
  yq -P -oy "$file"

}

# :command.function
repli_template_edit_command() {

  # src/commands/template/edit.sh
  local search="${args[search]}"
  template="$(select_template "$search")"
  file="$templates_dir/$template.yaml"
  "${EDITOR}" "$file"

}

# :command.function
repli_template_delete_command() {

  # src/commands/template/delete.sh
  local search="${args[search]}"
  template="$(select_template "$search")"
  file="$templates_dir/$template.yaml"
  log info "deleting $file"
  rm "$file"

}

# :command.function
repli_file_list_command() {

  # src/commands/file/list.sh
  plain="${args[--plain]}"
  json="${args[--json]}"

  if [[ -n "$json" ]]; then
    parser="jq"
    opts=()
  else
    parser="yq"
    opts=(-P)
  fi

  [[ -n "$plain" ]] && opts+=("-M")
  get_files_list | "$parser" "${opts[@]}" .results

}

# :command.function
repli_file_upload_command() {

  # src/commands/file/upload.sh
  file="${args[file]}"
  files_list="$output_dir/files.ini"

  if [[ -f "$files_list" ]]; then
    log debug reading files list: "$(blue "$files_list")"

    while IFS='=' read -r path url; do
      if [[ "$path" == "$file" ]]; then
        log info upload skipped, already registered in "$(blue "$files_list")"
        log info url: "$url"
        return 0
      fi
    done <"$files_list"
  fi

  log info uploading "$(blue "$file")"
  url="$(upload_to_replicate "$file")"
  log info url: "$(underlined "$url")"

  log info saving URL to "$(blue "$files_list")"
  echo "$file=$url" >>"$files_list"

}

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        repli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export REPLI_LOG_LEVEL="${REPLI_LOG_LEVEL:-info}"
  export REPLI_TEMPLATES_DIR="${REPLI_TEMPLATES_DIR:-$HOME/repli}"
  export REPLI_FILE="${REPLI_FILE:-repli.yaml}"
  export REPLI_OUTPUT_DIR="${REPLI_OUTPUT_DIR:-.}"
  export REPLICATE_HOST="${REPLICATE_HOST:-https://api.replicate.com}"

  env_var_names+=("REPLICATE_API_TOKEN")
  env_var_names+=("REPLI_LOG_LEVEL")
  env_var_names+=("REPLI_TEMPLATES_DIR")
  env_var_names+=("REPLI_FILE")
  env_var_names+=("REPLI_OUTPUT_DIR")
  env_var_names+=("REPLICATE_HOST")
  if [[ -z "${REPLICATE_API_TOKEN:-}" ]]; then
    printf "missing required environment variable: REPLICATE_API_TOKEN\n" >&2
    exit 1
  fi
  if [[ -n "${REPLI_LOG_LEVEL:-}" ]] && [[ ! ${REPLI_LOG_LEVEL:-} =~ ^(debug|info|warn|error)$ ]]; then
    printf "%s\n" "REPLI_LOG_LEVEL environment variable must be one of: debug, info, warn, error" >&2
    exit 1
  fi

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v yq >/dev/null 2>&1; then
    printf "missing dependency: yq\n" >&2
    missing_deps=1
  else
    deps['yq']="$(command -v yq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v curl >/dev/null 2>&1; then
    printf "missing dependency: curl\n" >&2
    missing_deps=1
  else
    deps['curl']="$(command -v curl | head -n1)"
  fi

  # :dependency.filter
  if ! command -v wget >/dev/null 2>&1; then
    printf "missing dependency: wget\n" >&2
    missing_deps=1
  else
    deps['wget']="$(command -v wget | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    new | n | init)
      action="new"
      shift
      repli_new_parse_requirements "$@"
      shift $#
      ;;

    get | g)
      action="get"
      shift
      repli_get_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      repli_edit_parse_requirements "$@"
      shift $#
      ;;

    show | s)
      action="show"
      shift
      repli_show_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      repli_env_parse_requirements "$@"
      shift $#
      ;;

    info | i)
      action="info"
      shift
      repli_info_parse_requirements "$@"
      shift $#
      ;;

    template | t)
      action="template"
      shift
      repli_template_parse_requirements "$@"
      shift $#
      ;;

    file | f)
      action="file"
      shift
      repli_file_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_new_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --exact | -e)

        # :flag.case_no_arg
        args['--exact']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_get_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['prefix']+x} ]]; then
          args['prefix']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_edit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_show_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --use | -u)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--use']="$2"
          shift
          shift
        else
          printf "%s\n" "--use requires an argument: --use, -u PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--use']:-} ]] || args['--use']="$REPLI_FILE"

  # :command.validations
  # :flag.validations
  if [[ -v args['--use'] ]]; then
    validation_output="$(validate_file_exists "${args['--use']:-}")"
    if [[ -n "${validation_output}" ]]; then
      printf "validation error in %s:\n%s\n" "--use, -u PATH" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_env_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_info_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --example | -e)
        # :flag.conflicts
        if [[ -n "${args['--schema']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--schema" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--example']=1
        shift
        ;;

      # :flag.case
      --schema | -s)
        # :flag.conflicts
        if [[ -n "${args['--example']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--example" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--schema']=1
        shift
        ;;

      # :flag.case
      --plain | -p)

        # :flag.case_no_arg
        args['--plain']=1
        shift
        ;;

      # :flag.case
      --json | -j)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: repli info MODEL [OPTIONS]\n" >&2
    # :command.examples_on_error
    printf "examples:\n" >&2
    printf "  repli info google/nano-banana\n" >&2
    printf "  repli info google/nano-banana --example --plain --json\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['model'] ]]; then
    validation_output="$(validate_model_name "${args['model']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "MODEL" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_template_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    new | n | add)
      action="new"
      shift
      repli_template_new_parse_requirements "$@"
      shift $#
      ;;

    list | ls)
      action="list"
      shift
      repli_template_list_parse_requirements "$@"
      shift $#
      ;;

    grep)
      action="grep"
      shift
      repli_template_grep_parse_requirements "$@"
      shift $#
      ;;

    show | s)
      action="show"
      shift
      repli_template_show_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      repli_template_edit_parse_requirements "$@"
      shift $#
      ;;

    delete | d | del | rm)
      action="delete"
      shift
      repli_template_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_template_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_template_new_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_new_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template new"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n NAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['model']+x} ]]; then
          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: repli template new MODEL [OPTIONS]\n" >&2
    # :command.examples_on_error
    printf "examples:\n" >&2
    printf "  repli add google/nano-banana --name banana\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--name']:-} ]] || args['--name']="auto"

  # :command.validations
  # :argument.validations
  if [[ -v args['model'] ]]; then
    validation_output="$(validate_model_name "${args['model']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "MODEL" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.parse_requirements
repli_template_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_template_grep_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_grep_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template grep"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['search']+x} ]]; then
    printf "missing required argument: SEARCH\nusage: repli template grep SEARCH\n" >&2

    exit 1
  fi

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_template_show_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_template_edit_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export EDITOR="${EDITOR:-vi}"

  env_var_names+=("EDITOR")

  # :command.command_filter
  action="template edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_template_delete_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_template_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="template delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_templates_dir_exists)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
repli_file_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_file_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      repli_file_list_parse_requirements "$@"
      shift $#
      ;;

    upload | u)
      action="upload"
      shift
      repli_file_upload_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      repli_file_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_file_list_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_file_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="file list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --plain | -p)

        # :flag.case_no_arg
        args['--plain']=1
        shift
        ;;

      # :flag.case
      --json | -j)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
repli_file_upload_parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        repli_file_upload_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="file upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['file']+x} ]]; then
          args['file']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['file']+x} ]]; then
    printf "missing required argument: FILE\nusage: repli file upload FILE\n" >&2

    exit 1
  fi

  # :command.validations
  # :argument.validations
  if [[ -v args['file'] ]]; then
    validation_output="$(validate_file_exists "${args['file']:-}")"
    if [[ -n "$validation_output" ]]; then
      printf "validation error in %s:\n%s\n" "FILE" "$validation_output" >&2
      exit 1
    fi
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.3"
  set -eo pipefail

  # :command.environment_variables_default
  export REPLI_LOG_LEVEL="${REPLI_LOG_LEVEL:-info}"
  export REPLI_TEMPLATES_DIR="${REPLI_TEMPLATES_DIR:-$HOME/repli}"
  export REPLI_FILE="${REPLI_FILE:-repli.yaml}"
  export REPLI_OUTPUT_DIR="${REPLI_OUTPUT_DIR:-.}"
  export REPLICATE_HOST="${REPLICATE_HOST:-https://api.replicate.com}"

  # :command.variables
  # :variable.definition
  declare -g output_dir="$REPLI_OUTPUT_DIR"

  # :variable.definition
  declare -g templates_dir="$REPLI_TEMPLATES_DIR"

  # :variable.definition
  declare -g log_level="$REPLI_LOG_LEVEL"

  # :variable.definition
  declare -g replicate_host="$REPLICATE_HOST"

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "new") repli_new_command ;;
    "get") repli_get_command ;;
    "edit") repli_edit_command ;;
    "show") repli_show_command ;;
    "env") repli_env_command ;;
    "info") repli_info_command ;;
    "template") repli_template_command ;;
    "template new") repli_template_new_command ;;
    "template list") repli_template_list_command ;;
    "template grep") repli_template_grep_command ;;
    "template show") repli_template_show_command ;;
    "template edit") repli_template_edit_command ;;
    "template delete") repli_template_delete_command ;;
    "file") repli_file_command ;;
    "file list") repli_file_list_command ;;
    "file upload") repli_file_upload_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
